<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">




















</head><body><pre>Date: Jan 20, 1999 10:08 PM
Author: George Marsaglia
Subject: Random numbers for C: End, at last?

My offer of RNG's for C was an invitation to dance;<br>I did not expect the Tarantella.  I hope this post will<br>stop the music, or at least slow it to a stately dance<br>for language chauvinists and software police---under<br>a different heading.<br><br>In response to a number of requests for good RNG's in<br>C, and mindful of the desirability of having a variety<br>of methods readily available, I offered several. They<br>were implemented as in-line functions using the #define<br>feature of C.<br><br>Numerous responses have led to improvements; the result<br>is the listing below, with comments describing the<br>generators.<br><br>I thank all the experts who contributed suggestions, either<br>directly to me or as part of the numerous threads.<br><br>It seems necessary to use a (circular) table in order<br>to get extremely long periods for some RNG's. Each new<br>number is some combination of the previous r numbers, kept<br>in the circular table.  The circular table has to keep<br>at least the last r, but possible more than r, numbers.<br><br>For speed, an  8-bit index seems best for accessing<br>members of the table---at least for Fortran, where an<br>8-bit integer is readily  available via integer*1, and<br>arithmetic on the index is automatically mod 256<br>(least-absolute-residue).<br><br>Having little experience with C, I got out my little<br>(but BIG) Kernighan and Ritchie book to see if there<br>were an 8-bit integer type. I found none, but I did<br>find char and unsigned char: one byte. Furthemore, K&amp;R<br>said arithmetic on characters was ok. That, and a study<br>of the #define examples, led me to propose #define's<br>for in-line generators LFIB4 and SWB, with monster<br>periods. But it turned out that char arithmetic jumps<br>"out of character", other than for simple cases such as<br>c++ or c+=1.   So, for safety, the index arithmetic<br>below is kept in character by the UC definition.<br><br>Another improvement on the original version  takes<br>advantage of the comma operator, which, to my chagrin,<br>I had not seen in K&amp;R.  It is there, but only with an<br>example of (expression,expression).  From the advice of<br>contributors, I found that the comma operator allows<br>(expression,...,expression,expression) with the<br>last expression determining the value.   That makes it<br>much easier to create in-line functions via #define<br>(see SHR3, LFIB4, SWB and FIB below).<br><br>The improved #define's are listed below, with a<br>function to initialize the table and a main program<br>that calls each of the in-line functions one million<br>times and then  compares the result to what I got with<br>a DOS version of gcc.   That main program can serve<br>as a test to see if your system produces the same<br>results as mine.<br>   _________________________________________<br>  |If you run the program below, your output|<br>  | should be  seven lines, each a 0 (zero).|<br>   -----------------------------------------<br><br>Some readers of the threads are not much interested<br>in the philosophical aspects of computer languages,<br>but want to know: what is the use of this stuff?<br>Here are simple examples of the use of the in-line<br>functions:  Include the #define's in your program, with<br>the accompanying static variable declarations, and a<br>procedure, such as the example, for initializing<br>the static variable (seeds) and the table.<br><br>Then any one of those in-line functions, inserted<br>in a C expression, will provide a random 32-bit<br>integer, or a random float if UNI or VNI is used.<br>For example, KISS&amp;255; would provide a random byte,<br>while 5.+2.*UNI; would provide a random real (float)<br>from 5 to 7. Or  1+MWC%10; would provide the<br>proverbial "take a number from 1 to 10",<br>(but with not quite, but virtually, equal<br> probabilities).<br>More generally, something such as 1+KISS%n; would<br>provide a practical uniform random choice from 1 to n,<br>if n is not too big.<br><br>A key point is: a wide variety of very fast, high-<br>quality, easy-to-use RNG's are available by means of<br>the nine in-line functions below, used individually or<br>in combination.<br><br>The comments after the main test program describe the<br>generators. These descriptions are much as in the first<br>post, for those who missed them. Some of the<br>generators (KISS, MWC, LFIB4) seem to pass all tests of<br>randomness, particularly the DIEHARD battery of tests,<br>and combining virtually any two or more of them should<br>provide fast, reliable, long period generators. (CONG<br>or FIB alone and CONG+FIB are suspect, but quite useful<br>in combinations.)<br><br>Serious users of random numbers may want to<br>run their simulations with several different<br>generators, to see if they get consistent results.<br>That should be easy to do.<br>Bonne chance,<br>George Marsaglia<br><br>The C code follows---------------------------------:<br><br>#include &lt;stdio.h&gt;<br>#define znew   (z=36969*(z&amp;65535)+(z&gt;&gt;16))<br>#define wnew   (w=18000*(w&amp;65535)+(w&gt;&gt;16))<br>#define MWC    ((znew&lt;&lt;16)+wnew )<br>#define SHR3  (jsr^=(jsr&lt;&lt;17), jsr^=(jsr&gt;&gt;13), jsr^=(jsr&lt;&lt;5))<br>#define CONG  (jcong=69069*jcong+1234567)<br>#define FIB   ((b=a+b),(a=b-a))<br>#define KISS  ((MWC^CONG)+SHR3)<br>#define LFIB4 (c++,t[c]=t[c]+t[UC(c+58)]+t[UC(c+119)]+t[UC(c+178)])<br>#define SWB   (c++,bro=(x&lt;y),t[c]=(x=t[UC(c+34)])-(y=t[UC(c+19)]+bro))<br>#define UNI   (KISS*2.328306e-10)<br>#define VNI   ((long) KISS)*4.656613e-10<br>#define UC    (unsigned char)  /*a cast operation*/<br>typedef unsigned long UL;<br><br>/*  Global static variables: */<br> static UL z=362436069, w=521288629, jsr=123456789, jcong=380116160;<br> static UL a=224466889, b=7584631, t[256];<br>/* Use random seeds to reset z,w,jsr,jcong,a,b, and the table t[256]*/<br><br> static UL x=0,y=0,bro; static unsigned char c=0;<br><br>/* Example procedure to set the table, using KISS: */<br> void settable(UL i1,UL i2,UL i3,UL i4,UL i5, UL i6)<br> { int i; z=i1;w=i2,jsr=i3; jcong=i4; a=i5; b=i6;<br> for(i=0;i&lt;256;i=i+1)  t[i]=KISS;<br> }<br><br>/* This is a test main program.  It should compile and print 7  0's. */<br>int main(void){<br>int i; UL k;<br>settable(12345,65435,34221,12345,9983651,95746118);<br><br>for(i=1;i&lt;1000001;i++){k=LFIB4;} printf("%u\n", k-1064612766U);<br>for(i=1;i&lt;1000001;i++){k=SWB  ;} printf("%u\n", k- 627749721U);<br>for(i=1;i&lt;1000001;i++){k=KISS ;} printf("%u\n", k-1372460312U);<br>for(i=1;i&lt;1000001;i++){k=CONG ;} printf("%u\n", k-1529210297U);<br>for(i=1;i&lt;1000001;i++){k=SHR3 ;} printf("%u\n", k-2642725982U);<br>for(i=1;i&lt;1000001;i++){k=MWC  ;} printf("%u\n", k- 904977562U);<br>for(i=1;i&lt;1000001;i++){k=FIB  ;} printf("%u\n", k-3519793928U);<br>              }<br>/*-----------------------------------------------------<br>   Write your own calling program and try one or more of<br>   the above, singly or in combination, when you run a<br>   simulation. You may want to change the simple 1-letter<br>   names, to avoid conflict with your own choices.        */<br><br>/* All that follows is comment, mostly from the initial<br>   post. You may want to remove it */<br><br>/* Any one of KISS, MWC, FIB, LFIB4, SWB, SHR3, or CONG<br>   can be used in an expression to provide a random 32-bit<br>   integer.<br><br>   The KISS generator, (Keep It Simple Stupid), is<br>   designed to combine the two multiply-with-carry<br>   generators in MWC with the 3-shift register SHR3 and<br>   the congruential generator CONG, using addition and<br>   exclusive-or. Period about 2^123.<br>   It is one of my favorite generators.<br><br>   The  MWC generator concatenates two 16-bit multiply-<br>   with-carry generators, x(n)=36969x(n-1)+carry,<br>   y(n)=18000y(n-1)+carry  mod 2^16, has period about<br>   2^60 and seems to pass all tests of randomness. A<br>   favorite stand-alone generator---faster than KISS,<br>   which contains it.<br><br>   FIB is the classical Fibonacci sequence<br>   x(n)=x(n-1)+x(n-2),but taken modulo 2^32.<br>   Its period is 3*2^31 if one of its two seeds is odd<br>   and not 1 mod 8. It has little worth as a RNG by<br>   itself, but provides a simple and fast component for<br>   use in combination generators.<br><br>   SHR3 is a 3-shift-register generator with period<br>   2^32-1. It uses y(n)=y(n-1)(I+L^17)(I+R^13)(I+L^5),<br>   with the y's viewed as binary vectors, L the 32x32<br>   binary matrix that shifts a vector left 1, and R its<br>   transpose.  SHR3 seems to pass all except those<br>   related to the binary rank test, since 32 successive<br>   values, as binary vectors, must be linearly<br>   independent, while 32 successive truly random 32-bit<br>   integers, viewed as binary vectors, will be linearly<br>   independent only about 29% of the time.<br><br>   CONG is a congruential generator with the widely used 69069<br>   multiplier: x(n)=69069x(n-1)+1234567.  It has period<br>   2^32. The leading half of its 32 bits seem to pass<br>   tests, but bits in the last half are too regular.<br><br>   LFIB4 is an extension of what I have previously<br>   defined as a lagged Fibonacci generator:<br>   x(n)=x(n-r) op x(n-s), with the x's in a finite<br>   set over which there is a binary operation op, such<br>   as +,- on integers mod 2^32, * on odd such integers,<br>   exclusive-or(xor) on binary vectors. Except for<br>   those using multiplication, lagged Fibonacci<br>   generators fail various tests of randomness, unless<br>   the lags are very long. (See SWB below).<br>   To see if more than two lags would serve to overcome<br>   the problems of 2-lag generators using +,- or xor, I<br>   have developed the 4-lag generator LFIB4 using<br>   addition: x(n)=x(n-256)+x(n-179)+x(n-119)+x(n-55)<br>   mod 2^32. Its period is 2^31*(2^256-1), about 2^287,<br>   and it seems to pass all tests---in particular,<br>   those of the kind for which 2-lag generators using<br>   +,-,xor seem to fail.  For even more confidence in<br>   its suitability,  LFIB4 can be combined with KISS,<br>   with a resulting period of about 2^410: just use<br>   (KISS+LFIB4) in any C expression.<br><br>   SWB is a subtract-with-borrow generator that I<br>   developed to give a simple method for producing<br>   extremely long periods:<br>      x(n)=x(n-222)-x(n-237)- borrow mod 2^32.<br>   The 'borrow' is 0, or set to 1 if computing x(n-1)<br>   caused overflow in 32-bit integer arithmetic. This<br>   generator has a very long period, 2^7098(2^480-1),<br>   about 2^7578.   It seems to pass all tests of<br>   randomness, except for the Birthday Spacings test,<br>   which it fails badly, as do all lagged Fibonacci<br>   generators using +,- or xor. I would suggest<br>   combining SWB with KISS, MWC, SHR3, or CONG.<br>   KISS+SWB has period &gt;2^7700 and is highly<br>   recommended.<br>   Subtract-with-borrow has the same local behaviour<br>   as lagged Fibonacci using +,-,xor---the borrow<br>   merely provides a much longer period.<br>   SWB fails the birthday spacings test, as do all<br>   lagged Fibonacci and other generators that merely<br>   combine two previous values by means of =,- or xor.<br>   Those failures are for a particular case: m=512<br>   birthdays in a year of n=2^24 days. There are<br>   choices of m and n for which lags &gt;1000 will also<br>   fail the test.  A reasonable precaution is to always<br>   combine a 2-lag Fibonacci or SWB generator with<br>   another kind of generator, unless the generator uses<br>   *, for which a very satisfactory sequence of odd<br>   32-bit integers results.<br><br>   The classical Fibonacci sequence mod 2^32 from FIB<br>   fails several tests.  It is not suitable for use by<br>   itself, but is quite suitable for combining with<br>   other generators.<br><br>   The last half of the bits of CONG are too regular,<br>   and it fails tests for which those bits play a<br>   significant role. CONG+FIB will also have too much<br>   regularity in trailing bits, as each does. But keep<br>   in mind that it is a rare application for which<br>   the trailing bits play a significant role.  CONG<br>   is one of the most widely used generators of the<br>   last 30 years, as it was the system generator for<br>   VAX and was incorporated in several popular<br>   software packages, all seemingly without complaint.<br><br>   Finally, because many simulations call for uniform<br>   random variables in 0&lt;x&lt;1 or -1&lt;x&lt;1, I use #define<br>   statements that permit inclusion of such variates<br>   directly in expressions:  using UNI will provide a<br>   uniform random real (float) in (0,1), while VNI will<br>   provide one in (-1,1).<br><br>   All of these: MWC, SHR3, CONG, KISS, LFIB4, SWB, FIB<br>   UNI and VNI, permit direct insertion of the desired<br>   random quantity into an expression, avoiding the<br>   time and space costs of a function call. I call<br>   these in-line-define functions.  To use them, static<br>   variables z,w,jsr,jcong,a and b should be assigned<br>   seed values other than their initial values.  If<br>   LFIB4 or SWB are used, the static table t[256] must<br>   be initialized.<br><br>   A note on timing:  It is difficult to provide exact<br>   time costs for inclusion of one of these in-line-<br>   define functions in an expression.  Times may differ<br>   widely for different compilers, as the C operations<br>   may be deeply nested and tricky. I suggest these<br>   rough comparisons, based on averaging ten runs of a<br>   routine that is essentially a long loop:<br>   for(i=1;i&lt;10000000;i++) L=KISS; then with KISS<br>   replaced with SHR3, CONG,... or KISS+SWB, etc. The<br>   times on my home PC, a Pentium 300MHz, in nanoseconds:<br>   FIB 49;LFIB4 77;SWB 80;CONG 80;SHR3 84;MWC 93;KISS 157;<br>   VNI 417;UNI 450;<br> */<br><br><br><br><br>
</pre>
</body></html>