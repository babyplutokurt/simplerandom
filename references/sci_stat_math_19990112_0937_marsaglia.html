<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">




















</head><body><pre>Date: Jan 12, 1999 9:37 AM
Author: George Marsaglia
Subject: Random numbers in C: Some suggestions.

<br>This posting ends with  17  lines of<br>C code that provide eight different<br>in-line random number generators, six for<br>random 32-bit integers and two for uniform<br>reals in (0,1) and (-1,1).<br>Comments are interspersed with that<br>code. Various combinations of the six in-line<br>integer generators may put in C expressions to<br>provide a wide variety of very fast, long period,<br>well-tested RNG's. I invite comments, feedback,<br>verifications and timings.<br><br>First, there is narrative giving background<br>for this posting; you may want to skip it.<br><br>Narrative:<br><br>Having had experience in producing and<br>testing for randomness in computers,<br>I am frequently asked to suggest good<br>random number generators (RNG's), test<br>RNG's, or comment on existing RNG's.  Many<br>recent queries have been in two areas:<br>(1) requests for implementations in C and<br>(2) comments on generators with immense periods,<br>particularly the Mersenne Twister.<br><br>This posting is mainly for category (1),<br>for which I suggest a set of C implementations<br>of RNG's I have developed.  C implementations<br>of my DIEHARD battery of tests will be<br>discussed elsewhere, and Narasimhan's GUI<br>version is expected to be released soon.<br><br>For (2), I merely repeat what I have said<br>in response to various queries: the Mersenne<br>Twister looks good, but it seems to be essentially<br>a lagged Fibonacci RNG using the exclusive-or<br>(xor) operation, and experience has shown that<br>lagged Fibonacci generators using xor provide<br>unsatisfactory 'randomness' unless the lags are<br>very long, and even for those with very long lags,<br>(and even for those using + or - rather than xor),<br>many people (I among them) are inclined to be<br>cautious about sequences based on such a simple<br>operation as: each new integer is the xor, (or sum,<br>or difference), of two earlier ones.  To be sure,<br>the resulting integers can be "twisted", but not,<br>I think, as simply or as safely as combining, say<br>by addition, with members of a sequence from a<br>(shorter period) generator that has itself passed<br>extensive tests of randomness.<br><br>I also reply that it does not take an immense<br>program (as, for example, in posted listings<br>of Twister) to produce a more satisfactory RNG<br>with an immense period, and give this example,<br>on which I will expand below: Inclusion of<br><br>#define SWB ( t[c+237]=(x=t[c+15])-(y=t[++c]+(x&lt;y)) )<br><br>together with suitably initialized seeds in<br><br>static unsigned long x,y,t[256]; unsigned char c;<br><br>will allow you to put the string SWB in any C<br>expression and it will provide, in about 100 nanosecs,<br>a 32-bit random integer with period  2^7578. (Here<br>and below, ^ means exponent, except in C expressions,<br>where it means xor (exclusive-or).<br><br>Now for the (2) part, in which I suggest a number<br>of C implementations and invite comment and feedback.<br>Most of these were previously developed and tested<br>via Fortran versions.  I list eight RNG's, each of<br>them by means of C's powerful #define device. This<br>provides  fast, compact implementation, allows<br>insertion of the required random variable directly<br>into an expression, and, finally, provides a good<br>selection of RNG's for use individually or in<br>combination.  The latter makes it possible to<br>further confirm what empirical results suggest:<br>combining two or more RNG's provides better,<br>(or no worse) randomness, and for encryption enthusiasts:<br>combination generators are harder to "crack".<br><br>For those wishing to try these eight RNG's:<br><br>At the top of your C program, include these<br>definitions and the static variables that follow.<br>Everything past this line is either C code or comment.<br>--------------------------------------------------<br><br>#define UL unsigned long<br>#define znew  ((z=36969*(z&amp;65535)+(z&gt;&gt;16))&lt;&lt;16)<br>#define wnew  ((w=18000*(w&amp;65535)+(w&gt;&gt;16))&amp;65535)<br>#define MWC   (znew+wnew)<br>#define SHR3  (jsr=(jsr=(jsr=jsr^(jsr&lt;&lt;17))^(jsr&gt;&gt;13))^(jsr&lt;&lt;5))<br>#define CONG  (jcong=69069*jcong+1234567)<br>#define KISS  ((MWC^CONG)+SHR3)<br>#define LFIB4 (t[c]=t[c]+t[c+58]+t[c+119]+t[++c+178])<br>#define SWB   (t[c+237]=(x=t[c+15])-(y=t[++c]+(x&lt;y)))<br>#define UNI   (KISS*2.328306e-10)<br>#define VNI   ((long) KISS)*4.656613e-10<br>/*  Global static variables: */<br> static UL z=362436069, w=521288629, jsr=123456789, jcong=380116160;<br> static UL t[256];<br> static UL x=0,y=0; static unsigned char c=0;<br><br>/* Random seeds must be used to reset z,w,jsr,jcong and<br>the table t[256]  Here is an example procedure, using KISS: */<br><br> void settable(UL i1,UL i2,UL i3,UL i4)<br> { int i; z=i1;w=i2,jsr=i3; jcong=i4;<br> for(i=0;i&lt;256;i++)  t[i]=KISS;        }<br><br>/*  End of C code;  Only comments follow. Stick the above<br>   17 lines in your simulation programs, initialize the table,<br>   and have a variety of promising RNG's at your disposal.  */<br><br>/* You may want use more complicated names for the<br>   above simple 1-letter variable names: z,w,x,y,t,c,<br>   to avoid clashing with favorites in your code.    */<br><br>/* Any one of KISS, MWC, LFIB4, SWB, SHR3, or CONG<br>   can be used in an expression to provide a random<br>   32-bit integer, and UNI in an expression will<br>   provide a random uniform in (01), or VNI in (-1,1).<br>   For example, for int i, float v; i=(MWC&gt;&gt;24); will<br>   provide a random byte, while v=4.+3.*UNI; will<br>   provide a uniform v in the interval 4. to 7.<br>   For the super cautious, (KISS+SWB) in an expression<br>   would provide a random 32-bit integer from<br>   a sequence with period &gt; 2^7700, and would only<br>   add some 300 nanoseconds to the computing<br>   time for that expression.                         */<br><br>/* The KISS generator, (Keep It Simple Stupid), is<br>   designed to combine the two multiply-with-carry<br>   generators in MWC with the 3-shift register SHR3<br>   and the congruential generator CONG, using<br>   addition and exclusive-or. Period about 2^123. It<br>   is one of my favorite generators.   */<br><br>/* The  MWC generator concatenates two 16-bit<br>  multiply-with-carry generators, x(n)=36969x(n-1)+carry,<br>  y(n)=18000y(n-1)+carry  mod 2^16, has  period  about<br>  2^60 and seems to pass all tests of randomness. A favorite<br>  stand-alone generator---faster than KISS, which contains it.*/<br><br>/* SHR3 is a 3-shift-register generator with<br>   period 2^32-1. It uses<br>   y(n)=y(n-1)(I+L^17)(I+R^13)(I+L^5), with the<br>   y's viewed as binary vectors, L the 32x32<br>   binary matrix that shifts a vector left 1, and<br>   R its transpose.  SHR3 seems to pass all except<br>   the binary rank test, since 32 successive<br>   values, as binary vectors, must be linearly<br>   independent, while 32 successive truly random<br>   32-bit integers, viewed as binary vectors, will<br>   be linearly independent only about 29% of the time.   */<br><br>/* CONG is a congruential generator with the<br>   widely used 69069 as multiplier:<br>   x(n)=69069x(n-1)+1234567.  It has period 2^32.<br>   The leading half of its 32 bits seem to pass<br>   all tests, but bits in the last half are too<br>   regular.                               */<br><br>/* LFIB4 is an extension of the class that I have<br>   previously defined as  lagged Fibonacci<br>   generators: x(n)=x(n-r) op x(n-s), with the x's<br>   in a finite set over which there is a binary<br>   operation op, such as +,- on integers mod 2^32,<br>   * on odd such integers, exclusive-or (xor) on<br>   binary vectors. Except for those using<br>   multiplication, lagged Fibonacci generators<br>   fail various tests of randomness, unless the<br>   lags are very long.  To see if more than two<br>   lags would serve to overcome the problems of 2-<br>   lag generators using +,- or xor, I have<br>   developed the 4-lag generator LFIB4:<br>   x(n)=x(n-256)+x(n-179)+x(n-119)+x(n-55) mod 2^32.<br>   Its period is 2^31*(2^256-1), about 2^287, and<br>   it seems to pass all tests---in particular,<br>   those of the kind for which 2-lag generators<br>   using +,-,xor seem to fail.  For even more<br>   confidence in its suitability,  LFIB4 can be<br>   combined with KISS, with a resulting period of<br>   about 2^410: just use (KISS+LFIB4) in any C<br>   expression.                               */<br><br>/* SWB is a subtract-with-borrow generator that I<br>   developed to give a simple method for producing<br>   extremely long periods:<br>   x(n)=x(n-222)-x(n-237)-borrow mod 2^32.<br>   The 'borrow' is 0 unless set to 1 if computing<br>   x(n-1) caused overflow in 32-bit integer<br>   arithmetic. This generator has a very long<br>   period, 2^7098(2^480-1), about 2^7578. It seems<br>   to pass all tests of randomness, but,<br>   suspicious of a generator so simple and fast<br>   (62 nanosecs at 300MHz), I would suggest<br>   combining SWB with KISS, MWC, SHR3, or CONG. */<br><br>/* Finally, because many simulations call for<br>   uniform random variables in 0&lt;v&lt;1 or -1&lt;v&lt;1, I<br>   use #define statements that permit inclusion of<br>   such variates directly in expressions:  using<br>   UNI will provide a uniform random real (float)<br>   in (0,1), while VNI will provide one in (-1,1).  */<br><br>/* All of these: MWC, SHR3, CONG, KISS, LFIB4,<br>   SWB, UNI and VNI, permit direct insertion of<br>   the desired random quantity into an expression,<br>   avoiding the time and space costs of a function<br>   call. I call these in-line-define functions.<br>   To use them, static variables z,w,jsr and<br>   jcong should be assigned seed values other than<br>   their initial values.  If LFIB4 or SWB are<br>   used, the static table t[256] must be<br>   initialized.  A sample procedure follows. */<br><br>/* A note on timing:  It is difficult to provide<br>   exact time costs for inclusion of one of these<br>   in-line-define functions in an expression.<br>   Times may differ widely for different<br>   compilers, as the C operations may be deeply<br>   nested and tricky. I suggest these rough<br>   comparisons, based on averaging ten runs of a<br>   routine that is essentially a long loop:<br>   for(i=1;i&lt;10000000;i++) L=KISS; then with KISS<br>   replaced with SHR3, CONG,... or KISS+SWB, etc.<br>   The times on my home PC, a Pentium 300MHz, in<br>   nanoseconds: LFIB4=64; CONG=90; SWB=100;<br>   SHR3=110; KISS=209; KISS+LFIB4=252; KISS+SWB=310.     */<br><br><br><br><br><br><br><br>
</pre>
</body></html>